use core::fmt;

#[derive(PartialEq, Debug, Clone, Copy)]
pub enum Reg {
    A,
    B,
    C,
    D,
    E,
    SP,
    H,
    L,
    Psw,
    M,
}

impl fmt::Display for Reg {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Reg::A => write!(f, "A"),
            Reg::B => write!(f, "B"),
            Reg::C => write!(f, "C"),
            Reg::D => write!(f, "D"),
            Reg::E => write!(f, "E"),
            Reg::SP => write!(f, "SP"),
            Reg::H => write!(f, "H"),
            Reg::L => write!(f, "L"),
            Reg::Psw => write!(f, "PSW"),
            Reg::M => write!(f, "M"),
        }
    }
}

#[derive(Debug, PartialEq, Clone, Copy)]
pub enum Instruction {
    NoOp,
    // Load Register Pair Immediate
    LXI { register: Reg, value: u16 },
    STAX { register: Reg },
    INX { register: Reg },
    // Increment Register / Increment Memory
    INR { register: Reg },
    DCR { register: Reg },
    MVI { register: Reg, value: u8 },
    RLC,
    // Add Register Pair to H and L
    DAD { register: Reg },
    LDAX { register: Reg },
    // Decrement Register Pair
    DCX { register: Reg },
    RRC,
    RAL,
    RAR,
    SHLD { address: u16 },
    CMA,
    DAA,
    LHLD { address: u16 },
    STA { address: u16 },
    STC,
    LDA { address: u16 },
    CMC,
    MOV { source: Reg, destination: Reg },
    HLT,
    ADD { register: Reg },
    ADC { register: Reg },
    SUB { register: Reg },
    SBB { register: Reg },
    ANA { register: Reg },
    XRA { register: Reg },
    ORA { register: Reg },
    CMP { register: Reg },
    RNZ,
    POP { register: Reg },
    JNZ { address: u16 },
    JMP { address: u16 },
    CNZ { address: u16 },
    PUSH { register: Reg },
    ADI { data: u8 },
    RST { data: u8 },
    RZ,
    RET,
    JZ { address: u16 },
    CZ { address: u16 },
    CALL { address: u16 },
    ACI { data: u8 },
    RNC,
    JNC { address: u16 },
    OUT { data: u8 },
    CNC { address: u16 },
    SUI { data: u8 },
    RC,
    JC { address: u16 },
    IN { data: u8 },
    CC { address: u16 },
    SBI { data: u8 },
    RPO,
    JPO { address: u16 },
    XTHL,
    CPO { address: u16 },
    ANI { data: u8 },
    RPE,
    PCHL,
    JPE { address: u16 },
    // Exchange H and L with D and E
    XCHG,
    CPE { address: u16 },
    XRI { data: u8 },
    RP,
    JP { address: u16 },
    DI,
    CP { address: u16 },
    ORI { data: u8 },
    RM,
    SPHL,
    JM { address: u16 },
    EI,
    CM { address: u16 },
    CPI { data: u8 },
}

impl fmt::Display for Instruction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Instruction::NoOp => write!(f, "NOP"),
            Instruction::LXI { register, value } => write!(f, "LXI {}, {:#06x}", register, value),
            Instruction::STAX { register } => write!(f, "STAX {}", register),
            Instruction::INX { register } => write!(f, "INX {}", register),
            Instruction::INR { register } => write!(f, "INR {}", register),
            Instruction::DCR { register } => write!(f, "DCR {}", register),
            Instruction::MVI { register, value } => write!(f, "MVI {} {:#04x}", register, value),
            Instruction::RLC => write!(f, "RLC"),
            Instruction::DAD { register } => write!(f, "DAD {}", register),
            Instruction::LDAX { register } => write!(f, "LDAX {}", register),
            Instruction::DCX { register } => write!(f, "DCX {}", register),
            Instruction::RRC => write!(f, "RRC"),
            Instruction::RAL => write!(f, "RAL"),
            Instruction::RAR => write!(f, "RAR"),
            Instruction::SHLD { address } => write!(f, "SHLD {:#06x}", address),
            Instruction::CMA => write!(f, "CMA"),
            Instruction::DAA => write!(f, "DAA"),
            Instruction::LHLD { address } => write!(f, "LHLD {:#06x}", address),
            Instruction::STA { address } => write!(f, "STA {:#06x}", address),
            Instruction::STC => write!(f, "STC"),
            Instruction::LDA { address } => write!(f, "LDA {:#06x}", address),
            Instruction::MOV {
                source,
                destination,
            } => write!(f, "MOV {}, {}", destination, source),
            Instruction::HLT => write!(f, "HLT"),
            Instruction::ADD { register } => write!(f, "ADD {}", register),
            Instruction::ADC { register } => write!(f, "ADC {}", register),
            Instruction::SUB { register } => write!(f, "SUB {}", register),
            Instruction::SBB { register } => write!(f, "SBB {}", register),
            Instruction::ANA { register } => write!(f, "ANA {}", register),
            Instruction::XRA { register } => write!(f, "XRA {}", register),
            Instruction::ORA { register } => write!(f, "ORA {}", register),
            Instruction::CMP { register } => write!(f, "CMP {}", register),
            Instruction::RNZ => write!(f, "RNZ"),
            Instruction::POP { register } => write!(f, "POP {}", register),
            Instruction::JNZ { address } => write!(f, "JNZ {:#06x}", address),
            Instruction::JMP { address } => write!(f, "JMP {:#06x}", address),
            Instruction::CNZ { address } => write!(f, "CNZ {:#06x}", address),
            Instruction::PUSH { register } => write!(f, "PUSH {}", register),
            Instruction::ADI { data } => write!(f, "ADI {:#04x}", data),
            Instruction::RST { data } => write!(f, "RST {}", data),
            Instruction::RZ => write!(f, "RZ"),
            Instruction::RET => write!(f, "RET"),
            Instruction::JZ { address } => write!(f, "JZ {:#06x}", address),
            Instruction::CZ { address } => write!(f, "CZ {:#06x}", address),
            Instruction::CALL { address } => write!(f, "CALL {:#06x}", address),
            Instruction::ACI { data } => write!(f, "ACI {:#04x}", data),
            Instruction::RNC => write!(f, "RNC"),
            Instruction::JNC { address } => write!(f, "JNC {:#06x}", address),
            Instruction::OUT { data } => write!(f, "OUT {:#04x}", data),
            Instruction::CNC { address } => write!(f, "CNC {:#06x}", address),
            Instruction::SUI { data } => write!(f, "SUI {:#04x}", data),
            Instruction::RC => write!(f, "RC"),
            Instruction::JC { address } => write!(f, "JC {:#06x}", address),
            Instruction::IN { data } => write!(f, "IN {:#04x}", data),
            Instruction::CC { address } => write!(f, "CC {:#06x}", address),
            Instruction::SBI { data } => write!(f, "SBI {:#04x}", data),
            Instruction::RPO => write!(f, "RPO"),
            Instruction::JPO { address } => write!(f, "JPO {:#06x}", address),
            Instruction::XTHL => write!(f, "XTHL"),
            Instruction::CPO { address } => write!(f, "CPO {:#06x}", address),
            Instruction::ANI { data } => write!(f, "ANI {:#04x}", data),
            Instruction::RPE => write!(f, "RPE"),
            Instruction::PCHL => write!(f, "PCHL"),
            Instruction::JPE { address } => write!(f, "JPE {:#06x}", address),
            Instruction::XCHG => write!(f, "XCHG"),
            Instruction::CPE { address } => write!(f, "CPE {:#06x}", address),
            Instruction::XRI { data } => write!(f, "XRI {:#04x}", data),
            Instruction::RP => write!(f, "RP"),
            Instruction::JP { address } => write!(f, "JP {:#06x}", address),
            Instruction::DI => write!(f, "DI"),
            Instruction::CP { address } => write!(f, "CP {:#06x}", address),
            Instruction::ORI { data } => write!(f, "ORI {:#04x}", data),
            Instruction::RM => write!(f, "RM"),
            Instruction::SPHL => write!(f, "SPHL"),
            Instruction::JM { address } => write!(f, "JM {:#06x}", address),
            Instruction::EI => write!(f, "EI"),
            Instruction::CM { address } => write!(f, "CM {:#06x}", address),
            Instruction::CPI { data } => write!(f, "CPI {:#04x}", data),
            Instruction::CMC => write!(f, "CMC"),
        }
    }
}

impl Instruction {
    pub fn op_bytes(&self) -> u8 {
        match self {
            Instruction::NoOp => 1,
            Instruction::LXI {
                register: _,
                value: _,
            } => 3,
            Instruction::STAX { register: _ } => 1,
            Instruction::INX { register: _ } => 1,
            Instruction::INR { register: _ } => 1,
            Instruction::DCR { register: _ } => 1,
            Instruction::MVI {
                register: _,
                value: _,
            } => 2,
            Instruction::RLC => 1,
            Instruction::DAD { register: _ } => 1,
            Instruction::LDAX { register: _ } => 1,
            Instruction::DCX { register: _ } => 1,
            Instruction::RRC => 1,
            Instruction::RAL => 1,
            Instruction::RAR => 1,
            Instruction::SHLD { address: _ } => 3,
            Instruction::CMA => 1,
            Instruction::DAA => 1,
            Instruction::LHLD { address: _ } => 3,
            Instruction::STA { address: _ } => 3,
            Instruction::STC => 1,
            Instruction::LDA { address: _ } => 3,
            Instruction::CMC => 1,
            Instruction::MOV {
                source: _,
                destination: _,
            } => 1,
            Instruction::HLT => 1,
            Instruction::ADD { register: _ } => 1,
            Instruction::ADC { register: _ } => 1,
            Instruction::SUB { register: _ } => 1,
            Instruction::SBB { register: _ } => 1,
            Instruction::ANA { register: _ } => 1,
            Instruction::XRA { register: _ } => 1,
            Instruction::ORA { register: _ } => 1,
            Instruction::CMP { register: _ } => 1,
            Instruction::RNZ => 1,
            Instruction::POP { register: _ } => 1,
            Instruction::JNZ { address: _ } => 3,
            Instruction::JMP { address: _ } => 3,
            Instruction::CNZ { address: _ } => 3,
            Instruction::PUSH { register: _ } => 1,
            Instruction::ADI { data: _ } => 2,
            Instruction::RST { data: _ } => 1,
            Instruction::RZ => 1,
            Instruction::RET => 1,
            Instruction::JZ { address: _ } => 3,
            Instruction::CZ { address: _ } => 3,
            Instruction::CALL { address: _ } => 3,
            Instruction::ACI { data: _ } => 2,
            Instruction::RNC => 1,
            Instruction::JNC { address: _ } => 3,
            Instruction::OUT { data: _ } => 2,
            Instruction::CNC { address: _ } => 3,
            Instruction::SUI { data: _ } => 2,
            Instruction::RC => 1,
            Instruction::JC { address: _ } => 3,
            Instruction::IN { data: _ } => 2,
            Instruction::CC { address: _ } => 3,
            Instruction::SBI { data: _ } => 2,
            Instruction::RPO => 1,
            Instruction::JPO { address: _ } => 3,
            Instruction::XTHL => 1,
            Instruction::CPO { address: _ } => 3,
            Instruction::ANI { data: _ } => 2,
            Instruction::RPE => 1,
            Instruction::PCHL => 1,
            Instruction::JPE { address: _ } => 3,
            Instruction::XCHG => 1,
            Instruction::CPE { address: _ } => 3,
            Instruction::XRI { data: _ } => 2,
            Instruction::RP => 1,
            Instruction::JP { address: _ } => 3,
            Instruction::DI => 1,
            Instruction::CP { address: _ } => 3,
            Instruction::ORI { data: _ } => 2,
            Instruction::RM => 1,
            Instruction::SPHL => 1,
            Instruction::JM { address: _ } => 3,
            Instruction::EI => 1,
            Instruction::CM { address: _ } => 3,
            Instruction::CPI { data: _ } => 2,
        }
    }

    pub(crate) fn decode(bin: &[u8]) -> Option<Self> {
        let val_one = bin.get(0);
        if let Some(val_one) = val_one {
            Some(match val_one {
                0x00 => Instruction::NoOp,
                0x01 => Instruction::LXI {
                    register: Reg::B,
                    value: address_from_slice(&bin[1..]),
                },
                0x02 => Instruction::STAX { register: Reg::B },
                0x03 => Instruction::INX { register: Reg::B },
                0x04 => Instruction::INR { register: Reg::B },
                0x05 => Instruction::DCR { register: Reg::B },
                0x06 => Instruction::MVI {
                    register: Reg::B,
                    value: *bin.get(1)?,
                },
                0x07 => Instruction::RLC,
                0x08 => return None,
                0x09 => Instruction::DAD { register: Reg::B },
                0x0a => Instruction::LDAX { register: Reg::B },
                0x0b => Instruction::DCX { register: Reg::B },
                0x0c => Instruction::INR { register: Reg::C },
                0x0d => Instruction::DCR { register: Reg::C },
                0x0e => Instruction::MVI {
                    register: Reg::C,
                    value: *bin.get(1)?,
                },
                0x0f => Instruction::RRC,
                0x10 => return None,
                0x11 => Instruction::LXI {
                    register: Reg::D,
                    value: address_from_slice(&bin[1..]),
                },
                0x12 => Instruction::STAX { register: Reg::D },
                0x13 => Instruction::INX { register: Reg::D },
                0x14 => Instruction::INR { register: Reg::D },
                0x15 => Instruction::DCR { register: Reg::D },
                0x16 => Instruction::MVI {
                    register: Reg::D,
                    value: *bin.get(1)?,
                },
                0x17 => Instruction::RAL,
                0x18 => return None,
                0x19 => Instruction::DAD { register: Reg::D },
                0x1a => Instruction::LDAX { register: Reg::D },
                0x1b => Instruction::DCX { register: Reg::D },
                0x1c => Instruction::INR { register: Reg::E },
                0x1d => Instruction::DCR { register: Reg::E },
                0x1e => Instruction::MVI {
                    register: Reg::E,
                    value: *bin.get(1)?,
                },
                0x1f => Instruction::RAR,
                0x20 => return None,
                0x21 => Instruction::LXI {
                    register: Reg::H,
                    value: address_from_slice(&bin[1..]),
                },
                0x22 => Instruction::SHLD {
                    address: address_from_slice(&bin[1..]),
                },
                0x23 => Instruction::INX { register: Reg::H },
                0x24 => Instruction::INR { register: Reg::H },
                0x25 => Instruction::DCR { register: Reg::H },
                0x26 => Instruction::MVI {
                    register: Reg::H,
                    value: *bin.get(1)?,
                },
                0x27 => Instruction::DAA,
                0x28 => return None,
                0x29 => Instruction::DAD { register: Reg::H },
                0x2a => Instruction::LHLD {
                    address: address_from_slice(&bin[1..]),
                },
                0x2b => Instruction::DCX { register: Reg::H },
                0x2c => Instruction::INR { register: Reg::L },
                0x2d => Instruction::DCR { register: Reg::L },
                0x2e => Instruction::MVI {
                    register: Reg::L,
                    value: *bin.get(1)?,
                },
                0x2f => Instruction::CMA,
                0x30 => return None,
                0x31 => Instruction::LXI {
                    register: Reg::SP,
                    value: address_from_slice(&bin[1..]),
                },
                0x32 => Instruction::STA {
                    address: address_from_slice(&bin[1..]),
                },
                0x33 => Instruction::INX { register: Reg::SP },
                0x34 => Instruction::INR { register: Reg::M },
                0x35 => Instruction::DCR { register: Reg::M },
                0x36 => Instruction::MVI {
                    register: Reg::M,
                    value: *bin.get(1)?,
                },
                0x37 => Instruction::STC,
                0x38 => return None,
                0x39 => Instruction::DAD { register: Reg::SP },
                0x3a => Instruction::LDA {
                    address: address_from_slice(&bin[1..]),
                },
                0x3b => Instruction::DCX { register: Reg::SP },
                0x3c => Instruction::INR { register: Reg::A },
                0x3d => Instruction::DCR { register: Reg::A },
                0x3e => Instruction::MVI {
                    register: Reg::A,
                    value: *bin.get(1)?,
                },
                0x3f => Instruction::CMC,
                0x40 => Instruction::MOV {
                    source: Reg::B,
                    destination: Reg::B,
                },
                0x41 => Instruction::MOV {
                    source: Reg::C,
                    destination: Reg::B,
                },
                0x42 => Instruction::MOV {
                    source: Reg::D,
                    destination: Reg::B,
                },
                0x43 => Instruction::MOV {
                    source: Reg::E,
                    destination: Reg::B,
                },
                0x44 => Instruction::MOV {
                    source: Reg::H,
                    destination: Reg::B,
                },
                0x45 => Instruction::MOV {
                    source: Reg::L,
                    destination: Reg::B,
                },
                0x46 => Instruction::MOV {
                    source: Reg::M,
                    destination: Reg::B,
                },
                0x47 => Instruction::MOV {
                    source: Reg::A,
                    destination: Reg::B,
                },
                0x48 => Instruction::MOV {
                    source: Reg::B,
                    destination: Reg::C,
                },
                0x49 => Instruction::MOV {
                    source: Reg::C,
                    destination: Reg::C,
                },
                0x4a => Instruction::MOV {
                    source: Reg::D,
                    destination: Reg::C,
                },
                0x4b => Instruction::MOV {
                    source: Reg::E,
                    destination: Reg::C,
                },
                0x4c => Instruction::MOV {
                    source: Reg::H,
                    destination: Reg::C,
                },
                0x4d => Instruction::MOV {
                    source: Reg::L,
                    destination: Reg::C,
                },
                0x4e => Instruction::MOV {
                    source: Reg::M,
                    destination: Reg::C,
                },
                0x4f => Instruction::MOV {
                    source: Reg::A,
                    destination: Reg::C,
                },
                0x50 => Instruction::MOV {
                    source: Reg::B,
                    destination: Reg::D,
                },
                0x51 => Instruction::MOV {
                    source: Reg::C,
                    destination: Reg::D,
                },
                0x52 => Instruction::MOV {
                    source: Reg::D,
                    destination: Reg::D,
                },
                0x53 => Instruction::MOV {
                    source: Reg::E,
                    destination: Reg::D,
                },
                0x54 => Instruction::MOV {
                    source: Reg::L,
                    destination: Reg::D,
                },
                0x55 => Instruction::MOV {
                    source: Reg::L,
                    destination: Reg::D,
                },
                0x56 => Instruction::MOV {
                    source: Reg::M,
                    destination: Reg::D,
                },
                0x57 => Instruction::MOV {
                    source: Reg::A,
                    destination: Reg::D,
                },
                0x58 => Instruction::MOV {
                    source: Reg::B,
                    destination: Reg::E,
                },
                0x59 => Instruction::MOV {
                    source: Reg::E,
                    destination: Reg::C,
                },
                0x5a => Instruction::MOV {
                    source: Reg::D,
                    destination: Reg::E,
                },
                0x5b => Instruction::MOV {
                    source: Reg::E,
                    destination: Reg::E,
                },
                0x5c => Instruction::MOV {
                    source: Reg::H,
                    destination: Reg::E,
                },
                0x5d => Instruction::MOV {
                    source: Reg::L,
                    destination: Reg::E,
                },
                0x5e => Instruction::MOV {
                    source: Reg::M,
                    destination: Reg::E,
                },
                0x5f => Instruction::MOV {
                    source: Reg::A,
                    destination: Reg::E,
                },
                0x60 => Instruction::MOV {
                    source: Reg::B,
                    destination: Reg::H,
                },
                0x61 => Instruction::MOV {
                    source: Reg::H,
                    destination: Reg::C,
                },
                0x62 => Instruction::MOV {
                    source: Reg::D,
                    destination: Reg::H,
                },
                0x63 => Instruction::MOV {
                    source: Reg::E,
                    destination: Reg::H,
                },
                0x64 => Instruction::MOV {
                    source: Reg::H,
                    destination: Reg::H,
                },
                0x65 => Instruction::MOV {
                    source: Reg::L,
                    destination: Reg::H,
                },
                0x66 => Instruction::MOV {
                    source: Reg::M,
                    destination: Reg::H,
                },
                0x67 => Instruction::MOV {
                    source: Reg::A,
                    destination: Reg::H,
                },
                0x68 => Instruction::MOV {
                    source: Reg::B,
                    destination: Reg::L,
                },
                0x69 => Instruction::MOV {
                    source: Reg::C,
                    destination: Reg::L,
                },
                0x6a => Instruction::MOV {
                    source: Reg::D,
                    destination: Reg::L,
                },
                0x6b => Instruction::MOV {
                    source: Reg::E,
                    destination: Reg::L,
                },
                0x6c => Instruction::MOV {
                    source: Reg::H,
                    destination: Reg::L,
                },
                0x6d => Instruction::MOV {
                    source: Reg::L,
                    destination: Reg::L,
                },
                0x6e => Instruction::MOV {
                    source: Reg::M,
                    destination: Reg::L,
                },
                0x6f => Instruction::MOV {
                    source: Reg::A,
                    destination: Reg::L,
                },
                0x70 => Instruction::MOV {
                    source: Reg::B,
                    destination: Reg::M,
                },
                0x71 => Instruction::MOV {
                    source: Reg::C,
                    destination: Reg::M,
                },
                0x72 => Instruction::MOV {
                    source: Reg::D,
                    destination: Reg::M,
                },
                0x73 => Instruction::MOV {
                    source: Reg::E,
                    destination: Reg::M,
                },
                0x74 => Instruction::MOV {
                    source: Reg::H,
                    destination: Reg::M,
                },
                0x75 => Instruction::MOV {
                    source: Reg::L,
                    destination: Reg::M,
                },
                0x76 => Instruction::HLT, //  1    special
                0x77 => Instruction::MOV {
                    source: Reg::A,
                    destination: Reg::M,
                },
                0x78 => Instruction::MOV {
                    source: Reg::B,
                    destination: Reg::A,
                },
                0x79 => Instruction::MOV {
                    source: Reg::C,
                    destination: Reg::A,
                },
                0x7a => Instruction::MOV {
                    source: Reg::D,
                    destination: Reg::A,
                },
                0x7b => Instruction::MOV {
                    source: Reg::E,
                    destination: Reg::A,
                },
                0x7c => Instruction::MOV {
                    source: Reg::H,
                    destination: Reg::A,
                },
                0x7d => Instruction::MOV {
                    source: Reg::L,
                    destination: Reg::A,
                },
                0x7e => Instruction::MOV {
                    source: Reg::M,
                    destination: Reg::A,
                },
                0x7f => Instruction::MOV {
                    source: Reg::A,
                    destination: Reg::A,
                },
                0x80 => Instruction::ADD { register: Reg::B },
                0x81 => Instruction::ADD { register: Reg::C },
                0x82 => Instruction::ADD { register: Reg::D },
                0x83 => Instruction::ADD { register: Reg::E },
                0x84 => Instruction::ADD { register: Reg::H },
                0x85 => Instruction::ADD { register: Reg::L },
                0x86 => Instruction::ADD { register: Reg::M },
                0x87 => Instruction::ADD { register: Reg::A },
                0x88 => Instruction::ADC { register: Reg::B },
                0x89 => Instruction::ADC { register: Reg::C },
                0x8a => Instruction::ADC { register: Reg::D },
                0x8b => Instruction::ADC { register: Reg::E },
                0x8c => Instruction::ADC { register: Reg::H },
                0x8d => Instruction::ADC { register: Reg::L },
                0x8e => Instruction::ADC { register: Reg::M },
                0x8f => Instruction::ADC { register: Reg::A },
                0x90 => Instruction::SUB { register: Reg::B },
                0x91 => Instruction::SUB { register: Reg::C },
                0x92 => Instruction::SUB { register: Reg::D },
                0x93 => Instruction::SUB { register: Reg::E },
                0x94 => Instruction::SUB { register: Reg::H },
                0x95 => Instruction::SUB { register: Reg::L },
                0x96 => Instruction::SUB { register: Reg::M },
                0x97 => Instruction::SUB { register: Reg::A },
                0x98 => Instruction::SBB { register: Reg::B },
                0x99 => Instruction::SBB { register: Reg::C },
                0x9a => Instruction::SBB { register: Reg::D },
                0x9b => Instruction::SBB { register: Reg::E },
                0x9c => Instruction::SBB { register: Reg::H },
                0x9d => Instruction::SBB { register: Reg::L },
                0x9e => Instruction::SBB { register: Reg::M },
                0x9f => Instruction::SBB { register: Reg::A },
                0xa0 => Instruction::ANA { register: Reg::B },
                0xa1 => Instruction::ANA { register: Reg::C },
                0xa2 => Instruction::ANA { register: Reg::D },
                0xa3 => Instruction::ANA { register: Reg::E },
                0xa4 => Instruction::ANA { register: Reg::H },
                0xa5 => Instruction::ANA { register: Reg::L },
                0xa6 => Instruction::ANA { register: Reg::M },
                0xa7 => Instruction::ANA { register: Reg::A },
                0xa8 => Instruction::XRA { register: Reg::B },
                0xa9 => Instruction::XRA { register: Reg::C },
                0xaa => Instruction::XRA { register: Reg::D },
                0xab => Instruction::XRA { register: Reg::E },
                0xac => Instruction::XRA { register: Reg::H },
                0xad => Instruction::XRA { register: Reg::L },
                0xae => Instruction::XRA { register: Reg::M },
                0xaf => Instruction::XRA { register: Reg::A },
                0xb0 => Instruction::ORA { register: Reg::B },
                0xb1 => Instruction::ORA { register: Reg::C },
                0xb2 => Instruction::ORA { register: Reg::D },
                0xb3 => Instruction::ORA { register: Reg::E },
                0xb4 => Instruction::ORA { register: Reg::H },
                0xb5 => Instruction::ORA { register: Reg::L },
                0xb6 => Instruction::ORA { register: Reg::M },
                0xb7 => Instruction::ORA { register: Reg::A },
                0xb8 => Instruction::CMP { register: Reg::B },
                0xb9 => Instruction::CMP { register: Reg::C },
                0xba => Instruction::CMP { register: Reg::D },
                0xbb => Instruction::CMP { register: Reg::E },
                0xbc => Instruction::CMP { register: Reg::H },
                0xbd => Instruction::CMP { register: Reg::L },
                0xbe => Instruction::CMP { register: Reg::M },
                0xbf => Instruction::CMP { register: Reg::A },
                0xc0 => Instruction::RNZ, //  1    if NZ, RET
                0xc1 => Instruction::POP { register: Reg::B },
                0xc2 => Instruction::JNZ {
                    address: address_from_slice(&bin[1..]),
                },
                0xc3 => Instruction::JMP {
                    address: address_from_slice(&bin[1..]),
                },
                0xc4 => Instruction::CNZ {
                    address: address_from_slice(&bin[1..]),
                },
                0xc5 => Instruction::PUSH { register: Reg::B },
                0xc6 => Instruction::ADI { data: *bin.get(1)? },
                0xc7 => Instruction::RST { data: 0 }, // 0  1    CALL $0
                0xc8 => Instruction::RZ,              //  1    if Z, RET
                0xc9 => Instruction::RET, //  1    PC.lo <- (sp); PC.hi<-(sp+1); SP <- SP+2
                0xca => Instruction::JZ {
                    address: address_from_slice(&bin[1..]),
                },
                0xcb => return None,
                0xcc => Instruction::CZ {
                    address: address_from_slice(&bin[1..]),
                },
                0xcd => Instruction::CALL {
                    address: address_from_slice(&bin[1..]),
                },
                0xce => Instruction::ACI { data: *bin.get(1)? },
                0xcf => Instruction::RST { data: 1 },
                0xd0 => Instruction::RNC,
                0xd1 => Instruction::POP { register: Reg::D },
                0xd2 => Instruction::JNC {
                    address: address_from_slice(&bin[1..]),
                },
                0xd3 => Instruction::OUT { data: *bin.get(1)? },
                0xd4 => Instruction::CNC {
                    address: address_from_slice(&bin[1..]),
                },
                0xd5 => Instruction::PUSH { register: Reg::D },
                0xd6 => Instruction::SUI { data: *bin.get(1)? },
                0xd7 => Instruction::RST { data: 2 },
                0xd8 => Instruction::RC,
                0xd9 => return None,
                0xda => Instruction::JC {
                    address: address_from_slice(&bin[1..]),
                },
                0xdb => Instruction::IN { data: *bin.get(1)? },
                0xdc => Instruction::CC {
                    address: address_from_slice(&bin[1..]),
                },
                0xdd => return None,
                0xde => Instruction::SBI { data: *bin.get(1)? },
                0xdf => Instruction::RST { data: 3 },
                0xe0 => Instruction::RPO,
                0xe1 => Instruction::POP { register: Reg::H },
                0xe2 => Instruction::JPO {
                    address: address_from_slice(&bin[1..]),
                },
                0xe3 => Instruction::XTHL,
                0xe4 => Instruction::CPO {
                    address: address_from_slice(&bin[1..]),
                },
                0xe5 => Instruction::PUSH { register: Reg::H },
                0xe6 => Instruction::ANI { data: *bin.get(1)? },
                0xe7 => Instruction::RST { data: 4 },
                0xe8 => Instruction::RPE,
                0xe9 => Instruction::PCHL,
                0xea => Instruction::JPE {
                    address: address_from_slice(&bin[1..]),
                },
                0xeb => Instruction::XCHG,
                0xec => Instruction::CPE {
                    address: address_from_slice(&bin[1..]),
                },
                0xed => return None,
                0xee => Instruction::XRI { data: *bin.get(1)? },
                0xef => Instruction::RST { data: 5 },
                0xf0 => Instruction::RP,
                0xf1 => Instruction::POP { register: Reg::Psw },
                0xf2 => Instruction::JP {
                    address: address_from_slice(&bin[1..]),
                },
                0xf3 => Instruction::DI,
                0xf4 => Instruction::CP {
                    address: address_from_slice(&bin[1..]),
                },
                0xf5 => Instruction::PUSH { register: Reg::Psw },
                0xf6 => Instruction::ORI { data: *bin.get(1)? },
                0xf7 => Instruction::RST { data: 6 },
                0xf8 => Instruction::RM,
                0xf9 => Instruction::SPHL,
                0xfa => Instruction::JM {
                    address: address_from_slice(&bin[1..]),
                },
                0xfb => Instruction::EI,
                0xfc => Instruction::CM {
                    address: address_from_slice(&bin[1..]),
                },
                0xfd => return None,
                0xfe => Instruction::CPI { data: *bin.get(1)? },
                0xff => Instruction::RST { data: 7 },
            })
        } else {
            None
        }
    }
}

fn address_from_slice(slice: &[u8]) -> u16 {
    ((slice[1] as u16) << 8) + (slice[0] as u16)
}
